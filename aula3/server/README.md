

# Spring Framework (back-end) - Permissões de Usuário na API

## Introdução

O Spring é um conjunto de projetos que focam em levar produtividade ao programador. Auxiliando de maneira a aumentar a produtividade no desenvolvimento de aplicações Java com simplicidade e flexibilidade.
Dentre o conjunto de frameworks do projeto Spring está o [Spring Security](https://github.com/spring-projects) [1].
O framework Spring Security fornece autenticação, autorização, e proteção contra os [ataques mais comuns](https://docs.spring.io/spring-security/reference/features/exploits/index.html) [2] em aplicações web.

## Criação da classe de permissões

O projeto **server** presente nas aulas 1 e 2 possui autenticação configurada, entretanto não existem permissões individuais para os diferentes *endpoints* da aplicação. Para adicionar essa funcionalidade será adicionada uma classe que irá representar as permissões de usuário, chamada de **Authority**. Para herdar as características de autorização do Spring Security essa classe deverá implementar **GrantedAuthority** e sobrescrever o método ***getAuthority()*** o qual irá retornar uma permissão de usuário, que será utilizada para autorizar os usuários com essa permissão ao acessar os *endpoints* da API. 

```java
package br.edu.utfpr.pb.pw26s.server.model;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.proxy.HibernateProxy;
import org.springframework.security.core.GrantedAuthority;
import java.util.Objects;

@Entity
@Table(name = "tb_authority")
@Getter @Setter
@ToString
@RequiredArgsConstructor
public class Authority implements GrantedAuthority {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String authority;

    @Override
    public final boolean equals(Object o) {
        if (this == o) return true;
        if (o == null) return false;
        Class<?> oEffectiveClass = o instanceof HibernateProxy ? ((HibernateProxy) o).getHibernateLazyInitializer().getPersistentClass() : o.getClass();
        Class<?> thisEffectiveClass = this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass() : this.getClass();
        if (thisEffectiveClass != oEffectiveClass) return false;
        Authority authority = (Authority) o;
        return getId() != null && Objects.equals(getId(), authority.getId());
    }

    @Override
    public final int hashCode() {
        return this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass().hashCode() : getClass().hashCode();
    }
}
```
Outro resultado da criação da classe será uma nova tabela no banco de dados de acordo com o *script* abaixo:
```sql
create table tb_authority (
	id bigint generated by default as identity,
    authority varchar(50),
    primary key (id)
);
```
Essa modificação deverá ser realizada nos *scripts* gerenciados pelo **Flyway**, para que ao executar a aplicação as modificações sejam refletidas no banco de dados.

## Ajuste da classe de usuários

Após criada a classe com as permissões é necessário adicionar o atributo que irá definir a lista de permissões de um usuário, para isso é necessário modificar a classe **User** adicionando o atributo **userAuthorities** que irá armazenar a lista de permissões e modificar o método **getAuthorities()** que irá retornar a lista de permissões para o Spring Security:
```java
	//...
    @ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinTable(name = "tb_user_authorities",
        joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id"),
        inverseJoinColumns = @JoinColumn(name = "authority_id", referencedColumnName = "id") )
    private Set<Authority> userAuthorities;

    @Override
    @Transient
    @JsonIgnore
    public Collection<? extends GrantedAuthority> getAuthorities() {
         return new ArrayList<>(userAuthorities);
    }
    //...
```
Assim como ao criar a classe *Authority* ao adicionar o atributo **userAuthorities** o banco de dados necessitará de ajustes, nesse caso, como um usuário poderá ter várias permissões e uma permissão poderá estar relacionada com mais de um usuário, será criada uma nova tabela que irá armazenar os dados do relacionamento entre **user** e **authority**

```sql
create table tb_user_authorities (
    user_id bigint,
    authority_id bigint
);
alter table tb_user_authorities add constraint FK_User_User_Authorities
    foreign key (user_id) references tb_user;
alter table tb_user_authorities add constraint FK_Authority_User_Authorities
    foreign key (authority_id) references tb_authority;
```
Essa modificação também deverá ser realizada nos *scripts* gerenciados pelo **Flyway**, para que ao executar a aplicação as modificações sejam refletidas no banco de dados. 

## Atribuindo permissões aos novos usuários

Agora já é possível registrar um usuário e atribuir permissões a ele. Antes é necessário adicionar permissões no banco de dados, por isso no *script* **V1.1__Data.sql** está o seguinte trecho: 
```sql
insert into tb_authority (authority) values ('ROLE_ADMIN');
insert into tb_authority (authority) values ('ROLE_USER');
```
Esses dois comandos SQL inserem as permissões **ROLE_ADMIN** e **ROLE_USER**. Por padrão no *framework* Spring Security as permissões sempre irão ter o prefixo _ROLE__ e restante da expressão pode ser qualquer _string_ (ex.: ROLE_ALUNO, ROLE_STUDENT, ROLE_PROFESSOR, etc).

## Inserindo um novo usuário com permissão USER

O primeiro passo será permitir o acesso aos dados de permissões criando o **AuthorityRepository**.

```java
package br.edu.utfpr.pb.pw26s.server.repository;

import model.br.edu.utfpr.pb.pw45s.server.Authority;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AuthorityRepository extends JpaRepository<Authority, Long> {
    Authority findByAuthority(String authority);
}
```

Agora já é possível acessar as permissões do banco de dados e associá-la um usuário, para isso basta adicionar o método ***save()*** da classe **UserService**:

```java
package br.edu.utfpr.pb.pw26s.server.service;

import model.br.edu.utfpr.pb.pw45s.server.User;
import repository.br.edu.utfpr.pb.pw45s.server.AuthorityRepository;
import repository.br.edu.utfpr.pb.pw45s.server.UserRepository;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.HashSet;

@Service
public class UserService {
    private final UserRepository userRepository;
    private final AuthorityRepository authorityRepository;
    BCryptPasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, AuthorityRepository authorityRepository) {
        this.userRepository = userRepository;
        this.authorityRepository = authorityRepository;
        passwordEncoder = new BCryptPasswordEncoder();
    }

    public User save(User user) {
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        user.setUserAuthorities(new HashSet<>());
        user.getUserAuthorities().add(authorityRepository.findByAuthority("ROLE_USER"));
        return userRepository.save(user);
    }
}
```
No exemplo acima a permissão **ROLE_USER** é adicionada à lista de permissões do usuário e o objeto é persistido no banco de dados. Com isso quando o usuário autenticar-se ele irá receber o **token** de autenticação e nas novas requisições terá acesso apenas aos **endpoints** com permissão para **ROLE_USER**.

## Configurando as permissões dos _endpoints_

As permissões de acesso estão configuradas na classe WebSecurity, para configurar os _endpoints_ da API de acordo com as novas permissões basta ajustar o conteúdo do método ***filterChain()***:
```java
 @Bean
    @SneakyThrows
    public SecurityFilterChain filterChain(HttpSecurity http) {
        // authenticationManager -> responsável pela autenticação dos usuários
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder.userDetailsService(authService)
                .passwordEncoder( passwordEncoder() );
        AuthenticationManager authenticationManager = authenticationManagerBuilder.build();

        //Configuração para funcionar o console do H2.
        http.headers(headers -> headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::disable));
        http.csrf(AbstractHttpConfigurer::disable);
        http.exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(authenticationEntryPoint));
        http.cors(AbstractHttpConfigurer::disable);
        http.authorizeHttpRequests((authorize) -> authorize
                .requestMatchers(antMatcher(HttpMethod.POST, "/users/**")).permitAll()
                .requestMatchers(antMatcher("/h2-console/**")).permitAll()
                .requestMatchers(antMatcher("/error/**")).permitAll()
                .requestMatchers(antMatcher("/actuator/**")).permitAll()

                .requestMatchers(antMatcher("/products/**")).hasAnyRole("ADMIN")
                .requestMatchers(antMatcher(HttpMethod.GET, "/categories/**")).hasAnyRole("ADMIN","USER")
                .requestMatchers(antMatcher("/categories/**")).hasAnyRole("ADMIN")

                .anyRequest().authenticated()
        );
        http.authenticationManager(authenticationManager)
                //Filtro de Autenticação
                .addFilter(new JWTAuthenticationFilter(authenticationManager, authService))
                //Filtro de Autorização
                .addFilter(new JWTAuthorizationFilter(authenticationManager, authService))
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

        return http.build();
    }
```
Alguns exemplos de configuração apresentados nó código acima

```java
// Necessário permissão de ADMIN para acessar o endpoint /products
.requestMatchers(antMatcher("/products/**")).hasAnyRole("ADMIN")
```
```java
// Necessário permissão de ADMIN ou USER para acessar o endpoint /cagories utilizando o método HTTP GET
.requestMatchers(antMatcher(HttpMethod.GET, "/categories/**")).hasAnyRole("ADMIN","USER")
```

```java
// Necessário permissão de ADMIN para acessar o endpoint /cagories utilizando os outros métodos HTTP
.requestMatchers(antMatcher("/categories/**")).hasAnyRole("ADMIN")
```

Como pode ser observado, para configurar cada _endpoint_ basta adicionar a permissão do usuário de acordo com o método HTTP. Sendo o método HTTP opcional, ou seja, uma mesma permissão pode ser utilizada para todos os métodos HTTP de um determinado _endpoint_. Com isso as configurações de permissão de usuário estão efetuadas e testes podem ser realizados afim de verificar o nível de acesso de cada permissão.

# Referências
[1] Spring Framework, https://spring.io/

[2] Ataques em aplicações Web, https://docs.spring.io/spring-security/reference/features/exploits/index.html